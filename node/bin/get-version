#!/usr/bin/env node
var assert  = require('assert');
var os      = require('os');

var argv    = require('minimist')(process.argv.slice(2));
var concat  = require('concat-stream');
var semver  = require('semver');
var winston = require('winston');

var pkg = {};
var logger = new winston.Logger({
  transports: [
    new winston.transports.Console({
      handleExceptions: true,
      timestamp: true,
      level: process.env.LOG_LEVEL || 'info'
    })
  ]
});

function getEngineEntry(engine) {
  try {
    return pkg.engines[engine];
  } catch (e) {
    return false;
  }
}

function parseNodeVersions(input) {
  var versions = { node: [], iojs: [] };

  input.split(os.EOL).forEach(function (version) {
    var typeArray = version.indexOf('iojs-') !== -1 ? versions.iojs : versions.node;
    version = version.replace(/iojs-|\s|->|\x1b\[[0-9;]*m/g, '');
    typeArray.push(version);
  });

  return versions;
}

function getNodeVersion(input) {
  var version;
  var versions = parseNodeVersions(input);
  var iojsRange = getEngineEntry('iojs');
  var nodeRange = getEngineEntry('node');

  if (iojsRange) {
    logger.debug('matching %d iojs versions against %s', versions['iojs'].length, iojsRange, {});
    version = semver.maxSatisfying(versions['iojs'], iojsRange);
  }

  if ( ! version && nodeRange) {
    logger.debug('matching %d node versions against %s', versions['node'].length, nodeRange, {});
    version = semver.maxSatisfying(versions['node'], nodeRange);
    if ( ! version) {
      logger.debug('matching %d iojs versions against %s', versions['iojs'].length, nodeRange, {});
      version = semver.maxSatisfying(versions['iojs'], nodeRange);
    }
  }

  if ( ! version) {
    logger.debug('finding the most recent node version');
    version = semver.maxSatisfying(versions['node'], '*');
  }

  logger.debug('choosing node %s', version);
  return version;
}


function getNpmVersion(input) {
  var data = JSON.parse(input);
  var npmRange = getEngineEntry('npm');
  var version;

  if (npmRange) {
    logger.debug('matching %d npm versions against %s', data.versions.length, npmRange, {});
    version = semver.maxSatisfying(data.versions, npmRange);
  }

  if ( ! version) {
    logger.debug('finding the most recent npm version');
    version = data['dist-tags'].latest;
  }

  logger.debug('choosing npm %s', version);
  return version;
}

function getVersion(input) {
  var version;

  switch(argv.engine) {
    case 'node':
      version = getNodeVersion(input);
      break;
    case 'npm':
      version = getNpmVersion(input);
      break;
    default:
      throw new Error('unknown engine type');
  }

  process.stdout.write(version);
}

logger.debug('get-version', argv);

assert(argv.engine, 'Must specify engine');

if (argv.package) {
  pkg = require(argv.package);
}

// read stdin and run appropriate parser
process.stdin.pipe(concat({ encoding: 'string' }, getVersion));
